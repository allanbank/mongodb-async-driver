/*
 * #%L
 * JsonParser.jj - mongodb-async-driver - Allanbank Consulting, Inc.
 * %%
 * Copyright (C) 2011 - 2014 Allanbank Consulting, Inc.
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
options {
      STATIC = false;
      SUPPORT_CLASS_VISIBILITY_PUBLIC = false;
      ERROR_REPORTING = true;
      JAVA_UNICODE_ESCAPE = true;
      UNICODE_INPUT = true;
}

PARSER_BEGIN(JsonParser)
/*
 * #%L
 * JsonParser.jj - mongodb-async-driver - Allanbank Consulting, Inc.
 * %%
 * Copyright (C) 2011 - 2014 Allanbank Consulting, Inc.
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.allanbank.mongodb.bson.json;

import java.io.Reader;
import java.io.StringReader;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.TimeZone;
import java.util.concurrent.TimeUnit;

import com.allanbank.mongodb.bson.Document;
import com.allanbank.mongodb.bson.Element;
import com.allanbank.mongodb.bson.builder.ArrayBuilder;
import com.allanbank.mongodb.bson.builder.BuilderFactory;
import com.allanbank.mongodb.bson.builder.DocumentBuilder;
import com.allanbank.mongodb.bson.element.ObjectId;
import com.allanbank.mongodb.error.JsonParseException;
import com.allanbank.mongodb.bson.io.EndianUtils;
import com.allanbank.mongodb.util.IOUtils;

/**
 * Parser for JSON documents.  This parser does not handle functions or complex expressions.
 * <p>
 * The intent of this parser is not to create a full capability JSON parser but 
 * instead to provide a simplified parser that accepts most valid documents.  
 * This parsers may also accept invalid documents/programs.
 * </p>
 * <p>
 * This class is not currently part of the drivers API.  We intend to eventually provide some 
 * basic JSON-->Document functionality but are looking for feedback from the community
 * on that interface. 
 * </p>
 * <p>
 * Users should not utilize this class directly.  Instead they should use the 
 * {@link Json} static class.
 * </p>
 *
 * @see <a href="http://www.ietf.org/rfc/rfc4627.txt">RFC 4627</a>
 * @api.no This class is <b>NOT</b> part of the drivers API. This class may be
 *         mutated in incompatible ways between any two releases of the driver.
 * @copyright 2012-2013, Allanbank Consulting, Inc., All Rights Reserved
 */
@SuppressWarnings({ "unused", "javadoc", "deprecation" })
/* package */ class JsonParser {
    /** The default time zone. */
    public static final TimeZone UTC = TimeZone.getTimeZone("UTC");

    /** The time formats accepted/parsed. */
    private static final String[] DATE_FORMATS = new String[] {
            "yyyy-MM-dd'T'HH:mm:ss.SSSZ", "yyyy-MM-dd'T'HH:mm:ssZ",
            "yyyy-MM-dd'T'HH:mmZ", "yyyy-MM-dd'T'HH:mm:ss.SSS",
            "yyyy-MM-dd'T'HH:mm:ss", "yyyy-MM-dd'T'HH:mm",
            "yyyy-MM-dd HH:mm:ss.SSSZ", "yyyy-MM-dd HH:mm:ssZ",
            "yyyy-MM-dd HH:mmZ", "yyyy-MM-dd HH:mm:ss.SSS",
            "yyyy-MM-dd HH:mm:ss", "yyyy-MM-dd HH:mm", "yyyy-MM-dd", };

    /**
     * Create a new JsonParser.
     */
    public JsonParser() {
        this(new StringReader(""));
    }

    /**
     * Parses the current source of data.
     * 
     * @param text
     *            The text JSON to parse.
     * @return The Document or list of documents parsed.
     * @throws ParseException
     *             On a failure to parse the JSON document.
     */
    public Object parse(final String text) throws ParseException {
        ReInit(new StringReader(text));
        return parse();
    }

    /**
     * Parses the current source of data.
     * 
     * @param reader
     *            The text JSON to parse.
     * @return The Document or list of documents parsed.
     * @throws ParseException
     *             On a failure to parse the JSON document.
     */
    public Object parse(final Reader reader) throws ParseException {
        ReInit(reader);
        return parse();
    }

    /**
     * Converts the Base64 string to a binary array.
     * 
     * @param base64Token
     *            The Base64 encoded bytes.
     * @return The decoded bytes.
     * @throws JsonParseException
     *             On a failure to decodee the binary.
     */
    private byte[] toBinaryFromBase64(final Token base64Token)
            throws JsonParseException {
        final String base64 = trimQuotes(base64Token.image);
        try {
            return IOUtils.base64ToBytes(base64);
        }
        catch (final IllegalArgumentException iae) {
            throw new JsonParseException(iae.getMessage() + " (line "
                    + base64Token.beginLine + ", column "
                    + base64Token.beginColumn + ")", iae,
                    base64Token.beginLine, base64Token.beginColumn);
        }
    }

    /**
     * Converts the HEX string to a binary array.
     * 
     * @param hexToken
     *            The HEX encoded bytes.
     * @return The decoded bytes.
     * @throws JsonParseException
     *             On a failure to decodee the binary.
     */
    private byte[] toBinaryFromHex(final Token hexToken)
            throws JsonParseException {
        final String hex = trimQuotes(hexToken.image);
        try {
            return IOUtils.hexToBytes(hex);
        }
        catch (final IllegalArgumentException iae) {
            throw new JsonParseException(iae.getMessage() + " (line "
                    + hexToken.beginLine + ", column " + hexToken.beginColumn
                    + ")", iae, hexToken.beginLine, hexToken.beginColumn);
        }
    }

    /**
     * Parses the ISO date string into a long field.
     * 
     * @param timestampToken
     *            The timestamp string.
     * @return The Date for the time string.
     * @throws JsonParseException
     *             On a failure to parse the date string.
     */
    private Date toDate(final Token timestampToken) throws JsonParseException {

        Exception last = null;
        final String timestamp = trimQuotes(timestampToken.image);
        for (final String format : DATE_FORMATS) {
            final SimpleDateFormat f = new SimpleDateFormat(format);
            f.setTimeZone(UTC);
            try {
                return f.parse(timestamp);
            }
            catch (final java.text.ParseException pe) {
                // Ignore. Try the next.
                last = pe;
            }
        }

        throw new JsonParseException("Could not parse the time string '"
                + timestamp + "' @ line " + timestampToken.beginLine
                + ", column " + timestampToken.beginColumn + ".", last,
                timestampToken.beginLine, timestampToken.beginColumn);
    }

    /**
     * Parses the ISO date string into a long field.
     * 
     * @param timestampToken
     *            The timestamp string.
     * @return The Date for the time string.
     * @throws JsonParseException
     *             On a failure to parse the date string.
     */
    private Date toDateFromEpoch(final Token timestampToken)
            throws JsonParseException {

        try {
            return new Date(Long.parseLong(timestampToken.image));
        }
        catch (NumberFormatException nfe) {
            throw new JsonParseException("Could not parse the time milliseconds '"
                    + timestampToken.image + "' @ line " + timestampToken.beginLine
                    + ", column " + timestampToken.beginColumn + ".", nfe,
                    timestampToken.beginLine, timestampToken.beginColumn);
        }
    }

    /**
     * Converts the HEX string to an integer.
     * 
     * @param hexToken
     *            The HEX encoded bytes.
     * @return The decoded integer.
     * @throws JsonParseException
     *             On a failure to decodee the integer.
     */
    private int toIntFromHex(final Token hexToken) throws JsonParseException {
        String hex = trimQuotes(hexToken.image);
        if (hex.startsWith("0x") || hex.startsWith("0X")) {
            hex = hex.substring(2);
        }

        try {
            return Integer.parseInt(hex, 16);
        }
        catch (final NumberFormatException nfe) {
            throw new JsonParseException(nfe.getMessage() + " (line "
                    + hexToken.beginLine + ", column " + hexToken.beginColumn
                    + ")", nfe, hexToken.beginLine, hexToken.beginColumn);
        }
    }

    /**
     * Converts the timestamp and increment into a MongoTimestamp Long value..
     * 
     * @param timestampToken
     *            The Mongo timestamp value (seconds since UNIX Epoch).
     * @param incrementToken
     *            The increment for the Mongo Timestamp.
     * @return The MongoTimestamp long value.
     * @throws JsonParseException
     *             On a failure to decode the timestamp integers.
     */
    private long toMongoTimestamp(final Token timestampToken,
            final Token incrementToken) throws JsonParseException {
        long value = 0;

        final String timestamp = trimQuotes(timestampToken.image);
        final String increment = trimQuotes(incrementToken.image);
        try {
            final long timePortion = Long.parseLong(timestamp) & 0xFFFFFFFFL;

            // Time is specified in milliseconds but only store seconds
            // so we truncate the time to milliseconds.
            value = TimeUnit.MILLISECONDS.toSeconds(timePortion);
            value <<= Integer.SIZE;
            value += (Long.parseLong(increment) & 0xFFFFFFFFL);
        }
        catch (final NumberFormatException nfe) {
            throw new JsonParseException(nfe.getMessage() + " (line "
                    + timestampToken.beginLine + ", column "
                    + timestampToken.beginColumn + ")", nfe,
                    timestampToken.beginLine, timestampToken.beginColumn);
        }
        return value;
    }

    /**
     * Tries to create a Mongo Timestamp from the four tokens in a document that
     * looks like:
     * <code>{ $timestamp : { &lt;token1&gt; : &lt;token2&gt; , &lt;token3&gt; : &lt;token4&gt; } }</code>
     * The second and fourth tokens should be integers. The first and third
     * should be either 't' or 'i'.
     * 
     * @param t1
     *            The first token in the document.
     * @param t2
     *            The second token in the document, should be an integer.
     * @param t3
     *            The third token in the document.
     * @param t4
     *            The fourth token in the document, should be an integer.
     */
    private long toMongoTimestamp(Token t1, Token t2, Token t3, Token t4) {
        try {
            long t2Int = Long.parseLong(trimQuotes(t2.image));
            long t4Int = Long.parseLong(trimQuotes(t4.image));

            String t1Str = trimQuotes(t1.image);
            String t3Str = trimQuotes(t3.image);

            long value = 0;
            if ("t".equals(t1Str) && "i".equals(t3Str)) {
                // Time is specified in milliseconds but only store seconds
                // so we truncate the time to milliseconds.
                value = TimeUnit.MILLISECONDS.toSeconds(t2Int);
                value <<= Integer.SIZE;
                value += (t4Int & 0xFFFFFFFFL);
            }
            else if ("t".equals(t3Str) && "i".equals(t1Str)) {
                value = TimeUnit.MILLISECONDS.toSeconds(t4Int);
                value <<= Integer.SIZE;
                value += (t2Int & 0xFFFFFFFFL);
            }
            else {
                throw new JsonParseException(
                        "Invalid MongoDB Timestamp document at line "
                                + t1.beginLine + ", column " + t1.beginColumn
                                + ":", t1.beginLine, t1.beginColumn);
            }
            return value;
        }
        catch (NumberFormatException nfe) {
            throw new JsonParseException(nfe.getMessage() + " (line "
                    + t1.beginLine + ", column " + t1.beginColumn + ")", nfe,
                    t1.beginLine, t1.beginColumn);
        }
    }

    /**
     * Creates a ObjectId from the hex binary representation.
     * 
     * @param hexBytesToken
     *            The hex bytes for the ObjectId.
     * @return The ObjectId.
     * @throws JsonParseException
     *             On a failure to decode the hex binary into an ObjectId.
     */
    private ObjectId toObjectId(final Token hexBytesToken)
            throws JsonParseException {
        int timestamp = 0;
        long machineId = 0;

        final String hexBytes = trimQuotes(hexBytesToken.image);
        try {
            return new ObjectId(hexBytes);
        }
        catch (final IllegalArgumentException iae) {
            throw new JsonParseException(iae.getMessage() + " (line "
                    + hexBytesToken.beginLine + ", column "
                    + hexBytesToken.beginColumn + ")", iae,
                    hexBytesToken.beginLine, hexBytesToken.beginColumn);
        }
    }

    /**
     * Trims the quotes from the string.
     * 
     * @param string
     *            The string to trim the quotes from.
     * @return The string without the quotes.
     */
    private String trimQuotes(final String string) {
        if (!string.isEmpty()) {
            final int length = string.length();
            final char first = string.charAt(0);
            final char last = string.charAt(length - 1);
            if ((first == last) && ((first == '"') || (first == '\''))) {
                return string.substring(1, length - 1);
            }
        }

        return string;
    }
}
PARSER_END(JsonParser)

SKIP: {
        " "
    |   "\t"
    |   "\n"
    |   "\r"
    |   "\f"
}

// Comments - C/C++/Java style.
SKIP: {
    <COMMENT_LINE: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}
SKIP: {
    <COMMENT_BLOCK: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

/** Reserved Words */
TOKEN: {
        <TOKEN_TRUE: "true">
    |   <TOKEN_FALSE: "false">
    |   <TOKEN_NULL: "null">
}

/** JSON operators */
TOKEN: {
        <TOKEN_OPEN_BRACE: "{">
    |   <TOKEN_CLOSE_BRACE: "}">
    |   <TOKEN_OPEN_BRACKET: "[">
    |   <TOKEN_CLOSE_BRACKET: "]">
    |   <TOKEN_COMMA: ",">
    |   <TOKEN_COLON: ":">
    |   <TOKEN_DOT: ".">
    |   <TOKEN_PLUS: "+">
    |   <TOKEN_MINUS: "-">  
}

/** Numeric literals */
TOKEN: {
      <DOUBLE : <INTEGER> <FRACTIONAL_DIGITS> | <INTEGER> <EXPONENT> | <INTEGER> <FRACTIONAL_DIGITS> <EXPONENT> >
    | <INTEGER: (<TOKEN_MINUS>)? ( <DIGIT> | <NONZERO_DIGIT> <DIGITS> ) >
    
    | <#DIGIT: ["0" - "9"] >
    | <#NONZERO_DIGIT: ["1" - "9"] >
    | <#EXP: ["e", "E"] ( <TOKEN_PLUS > | <TOKEN_MINUS > )? >
    | <#FRACTIONAL_DIGITS: <TOKEN_DOT> <DIGITS > >
    | <#EXPONENT: <EXP> <DIGITS> >
    | <#DIGITS: ( <DIGIT> )+ >
}

/** String literals */
TOKEN : {
      < STRING_LITERAL : 
          "\"" (< DOUBLE_STRING_CHARACTERS >)? "\""
        | "'" (< SINGLE_STRING_CHARACTERS >)? "'" > 
        
    | < #DOUBLE_STRING_CHARACTERS : (< DOUBLE_STRING_CHARACTER >)* >
    | < #SINGLE_STRING_CHARACTERS : (< SINGLE_STRING_CHARACTER >)* >
    | < #DOUBLE_STRING_CHARACTER: (~["\"","\\","\n","\r","\u2028","\u2029"])  | "\\" <ESCAPE_SEQUENCE> >
    | < #SINGLE_STRING_CHARACTER: 
          (~["'","\\","\n","\r","\u2028","\u2029"])  
        | "\\" <ESCAPE_SEQUENCE> > 
    | < #ESCAPE_SEQUENCE : 
          < CHARACTER_ESCAPE_SEQUENCE > 
        | "0" 
        | < HEX_ESCAPE_SEQUENCE > 
        | < UNICODE_ESCAPE_SEQUENCE > >
    | < #CHARACTER_ESCAPE_SEQUENCE : < SINGLE_ESCAPE_CHARACTER > | < NON_ESCAPE_CHARACTER >>
    | < #SINGLE_ESCAPE_CHARACTER : [ "'", "\"", "\\", "b", "f", "n", "r", "t", "v" ] >
    | < #NON_ESCAPE_CHARACTER:  
          ~["\n","\r","\u2028","\u2029"]
        | ~["'" , "\"" , "\\" , "b" , "f" , "n" , "r" , "t" , "v", "x", "u"]
        | ~["0"-"9"] >
}

TOKEN : {
    < HEX_ESCAPE_SEQUENCE : "x" < HEX_DIGIT > < HEX_DIGIT >>
}
TOKEN : {
    < HEX_DIGIT : [ "0"-"9" ] | [ "a"-"f" ] | [ "A"-"F" ] >
}

/* Extension Object types. */
TOKEN : {
        <TOKEN_BINDATA: "BinData">
     |  <TOKEN_HEXDATA: "HexData">
     |  <TOKEN_ISODATE: "ISODate">
     |  <TOKEN_NUMBERLONG: "NumberLong">
     |  <TOKEN_OBJECTID: "ObjectId">
     |  <TOKEN_TIMESTAMP: "Timestamp">
     |  <TOKEN_MAXKEY: "MaxKey">
     |  <TOKEN_MINKEY: "MinKey">
     |  <TOKEN_DB_POINTER: "DBPointer">
     |  <TOKEN_BINARY: "\"$binary\"" |  "'$binary'" | "$binary" >
     |  <TOKEN_TYPE: "\"$type\"" |  "'$type'" | "$type" >
     |  <TOKEN_DATE: "\"$date\"" |  "'$date'" | "$date" >
     |  <TOKEN_TS: "\"$timestamp\"" |  "'$timestamp'" | "$timestamp" >
     |  <TOKEN_REGEX: "\"$regex\"" |  "'$regex'" | "$regex" >
     |  <TOKEN_OPTIONS: "\"$options\"" |  "'$options'" | "$options" >
     |  <TOKEN_OID: "\"$oid\"" |  "'$oid'" | "$oid" >
     |  <TOKEN_MAX: "\"$maxKey\"" |  "'$maxKey'" | "$maxKey" >
     |  <TOKEN_MIN: "\"$minKey\"" |  "'$minKey'" | "$minKey" >
}        

/* Identifiers */
TOKEN : {
      < IDENTIFIER_NAME : < IDENTIFIER_START > (< IDENTIFIER_PART >)* > 
      
    | < #IDENTIFIER_START :
          < UNICODE_LETTER >
        | < DOLLAR_SIGN >
        | < UNDER_SCORE >
        | < UNICODE_ESCAPE_SEQUENCE > >
    | < #IDENTIFIER_PART :
          < IDENTIFIER_START >
        | < UNICODE_COMBINING_MARK >
        | < UNICODE_DIGIT >
        | < UNICODE_CONNECTOR_PUNCTUATION >
        | < UNICODE_ESCAPE_SEQUENCE >>
        | < #DOLLAR_SIGN : "$" >
        | < #UNDER_SCORE : "_" >
        | < #UNICODE_LETTER :
              ["A"-"Z"]           | ["a"-"z"]           | ["\u0041"-"\u005A"] 
            | ["\u0061"-"\u007A"] | ["\u00AA"]          | ["\u00B5"]
            | ["\u00BA"]          | ["\u00C0"-"\u00D6"] | ["\u00D8"-"\u00F6"] 
            | ["\u00F8"-"\u021F"] | ["\u0222"-"\u0233"] | ["\u0250"-"\u02AD"] 
            | ["\u02B0"-"\u02B8"] | ["\u02BB"-"\u02C1"] | ["\u02D0"-"\u02D1"] 
            | ["\u02E0"-"\u02E4"] | ["\u02EE"]          | ["\u037A"]
            | ["\u0386"]          | ["\u0388"-"\u038A"] | ["\u038C"]
            | ["\u038E"-"\u03A1"] | ["\u03A3"-"\u03CE"] | ["\u03D0"-"\u03D7"] 
            | ["\u03DA"-"\u03F3"] | ["\u0400"-"\u0481"] | ["\u048C"-"\u04C4"]
            | ["\u04C7"-"\u04C8"] | ["\u04CB"-"\u04CC"] | ["\u04D0"-"\u04F5"]
            | ["\u04F8"-"\u04F9"] | ["\u0531"-"\u0556"] | ["\u0559"]
            | ["\u0561"-"\u0587"] | ["\u05D0"-"\u05EA"] | ["\u05F0"-"\u05F2"] 
            | ["\u0621"-"\u063A"] | ["\u0640"-"\u064A"] | ["\u0671"-"\u06D3"]
            | ["\u06D5"]          | ["\u06E5"-"\u06E6"] | ["\u06FA"-"\u06FC"]
            | ["\u0710"]          | ["\u0712"-"\u072C"] | ["\u0780"-"\u07A5"] 
            | ["\u0905"-"\u0939"] | ["\u093D"]          | ["\u0950"] 
            | ["\u0958"-"\u0961"] | ["\u0985"-"\u098C"] | ["\u098F"-"\u0990"] 
            | ["\u0993"-"\u09A8"] | ["\u09AA"-"\u09B0"] | ["\u09B2"]
            | ["\u09B6"-"\u09B9"] | ["\u09DC"-"\u09DD"] | ["\u09DF"-"\u09E1"] 
            | ["\u09F0"-"\u09F1"] | ["\u0A05"-"\u0A0A"] | ["\u0A0F"-"\u0A10"] 
            | ["\u0A13"-"\u0A28"] | ["\u0A2A"-"\u0A30"] | ["\u0A32"-"\u0A33"] 
            | ["\u0A35"-"\u0A36"] | ["\u0A38"-"\u0A39"] | ["\u0A59"-"\u0A5C"]
            | ["\u0A5E"]          | ["\u0A72"-"\u0A74"] | ["\u0A85"-"\u0A8B"] 
            | ["\u0A8D"]          | ["\u0A8F"-"\u0A91"] | ["\u0A93"-"\u0AA8"] 
            | ["\u0AAA"-"\u0AB0"] | ["\u0AB2"-"\u0AB3"] | ["\u0AB5"-"\u0AB9"] 
            | ["\u0ABD"]          | ["\u0AD0"]          | ["\u0AE0"]
            | ["\u0B05"-"\u0B0C"] | ["\u0B0F"-"\u0B10"] | ["\u0B13"-"\u0B28"] 
            | ["\u0B2A"-"\u0B30"] | ["\u0B32"-"\u0B33"] | ["\u0B36"-"\u0B39"] 
            | ["\u0B3D"]          | ["\u0B5C"-"\u0B5D"] | ["\u0B5F"-"\u0B61"] 
            | ["\u0B85"-"\u0B8A"] | ["\u0B8E"-"\u0B90"] | ["\u0B92"-"\u0B95"]
            | ["\u0B99"-"\u0B9A"] | ["\u0B9C"]          | ["\u0B9E"-"\u0B9F"] 
            | ["\u0BA3"-"\u0BA4"] | ["\u0BA8"-"\u0BAA"] | ["\u0BAE"-"\u0BB5"] 
            | ["\u0BB7"-"\u0BB9"] | ["\u0C05"-"\u0C0C"] | ["\u0C0E"-"\u0C10"] 
            | ["\u0C12"-"\u0C28"] | ["\u0C2A"-"\u0C33"] | ["\u0C35"-"\u0C39"]
            | ["\u0C60"-"\u0C61"] | ["\u0C85"-"\u0C8C"] | ["\u0C8E"-"\u0C90"]
            | ["\u0C92"-"\u0CA8"] | ["\u0CAA"-"\u0CB3"] | ["\u0CB5"-"\u0CB9"]
            | ["\u0CDE"]          | ["\u0CE0"-"\u0CE1"] | ["\u0D05"-"\u0D0C"]
            | ["\u0D0E"-"\u0D10"] | ["\u0D12"-"\u0D28"] | ["\u0D2A"-"\u0D39"]
            | ["\u0D60"-"\u0D61"] | ["\u0D85"-"\u0D96"] | ["\u0D9A"-"\u0DB1"]
            | ["\u0DB3"-"\u0DBB"] | ["\u0DBD"]          | ["\u0DC0"-"\u0DC6"]
            | ["\u0E01"-"\u0E30"] | ["\u0E32"-"\u0E33"] | ["\u0E40"-"\u0E46"]
            | ["\u0E81"-"\u0E82"] | ["\u0E84"]          | ["\u0E87"-"\u0E88"]
            | ["\u0E8A"]          | ["\u0E8D"]          | ["\u0E94"-"\u0E97"]
            | ["\u0E99"-"\u0E9F"] | ["\u0EA1"-"\u0EA3"] | ["\u0EA5"]
            | ["\u0EA7"]          | ["\u0EAA"-"\u0EAB"] | ["\u0EAD"-"\u0EB0"]
            | ["\u0EB2"-"\u0EB3"] | ["\u0EBD"-"\u0EC4"] | ["\u0EC6"]
            | ["\u0EDC"-"\u0EDD"] | ["\u0F00"]          | ["\u0F40"-"\u0F6A"]
            | ["\u0F88"-"\u0F8B"] | ["\u1000"-"\u1021"] | ["\u1023"-"\u1027"]
            | ["\u1029"-"\u102A"] | ["\u1050"-"\u1055"] | ["\u10A0"-"\u10C5"]
            | ["\u10D0"-"\u10F6"] | ["\u1100"-"\u1159"] | ["\u115F"-"\u11A2"]
            | ["\u11A8"-"\u11F9"] | ["\u1200"-"\u1206"] | ["\u1208"-"\u1246"]
            | ["\u1248"]          | ["\u124A"-"\u124D"] | ["\u1250"-"\u1256"]
            | ["\u1258"]          | ["\u125A"-"\u125D"] | ["\u1260"-"\u1286"]
            | ["\u1288"]          | ["\u128A"-"\u128D"] | ["\u1290"-"\u12AE"]
            | ["\u12B0"]          | ["\u12B2"-"\u12B5"] | ["\u12B8"-"\u12BE"]
            | ["\u12C0"]          | ["\u12C2"-"\u12C5"] | ["\u12C8"-"\u12CE"]
            | ["\u12D0"-"\u12D6"] | ["\u12D8"-"\u12EE"] | ["\u12F0"-"\u130E"]
            | ["\u1310"]          | ["\u1312"-"\u1315"] | ["\u1318"-"\u131E"]
            | ["\u1320"-"\u1346"] | ["\u1348"-"\u135A"] | ["\u13A0"-"\u13B0"]
            | ["\u13B1"-"\u13F4"] | ["\u1401"-"\u1676"] | ["\u1681"-"\u169A"]
            | ["\u16A0"-"\u16EA"] | ["\u1780"-"\u17B3"] | ["\u1820"-"\u1877"]
            | ["\u1880"-"\u18A8"] | ["\u1E00"-"\u1E9B"] | ["\u1EA0"-"\u1EE0"]
            | ["\u1EE1"-"\u1EF9"] | ["\u1F00"-"\u1F15"] | ["\u1F18"-"\u1F1D"]
            | ["\u1F20"-"\u1F39"] | ["\u1F3A"-"\u1F45"] | ["\u1F48"-"\u1F4D"]
            | ["\u1F50"-"\u1F57"] | ["\u1F59"]          | ["\u1F5B"]
            | ["\u1F5D"]          | ["\u1F5F"-"\u1F7D"] | ["\u1F80"-"\u1FB4"]
            | ["\u1FB6"-"\u1FBC"] | ["\u1FBE"]          | ["\u1FC2"-"\u1FC4"]
            | ["\u1FC6"-"\u1FCC"] | ["\u1FD0"-"\u1FD3"] | ["\u1FD6"-"\u1FDB"]
            | ["\u1FE0"-"\u1FEC"] | ["\u1FF2"-"\u1FF4"] | ["\u1FF6"-"\u1FFC"]
            | ["\u207F"]          | ["\u2102"]          | ["\u2107"]
            | ["\u210A"-"\u2113"] | ["\u2115"]          | ["\u2119"-"\u211D"]
            | ["\u2124"]          | ["\u2126"]          | ["\u2128"]
            | ["\u212A"-"\u212D"] | ["\u212F"-"\u2131"] | ["\u2133"-"\u2139"]
            | ["\u2160"-"\u2183"] | ["\u3005"-"\u3007"] | ["\u3021"-"\u3029"]
            | ["\u3031"-"\u3035"] | ["\u3038"-"\u303A"] | ["\u3041"-"\u3094"]
            | ["\u309D"-"\u309E"] | ["\u30A1"-"\u30FA"] | ["\u30FC"-"\u30FE"]
            | ["\u3105"-"\u312C"] | ["\u3131"-"\u318E"] | ["\u31A0"-"\u31B7"]
            | ["\u3400"]          | ["\u4DB5"]          | ["\u4E00"]
            | ["\u9FA5"]          | ["\uA000"-"\uA48C"] | ["\uAC00"]
            | ["\uD7A3"]          | ["\uF900"-"\uFA2D"] | ["\uFB00"-"\uFB06"]
            | ["\uFB13"-"\uFB17"] | ["\uFB1D"]          | ["\uFB1F"-"\uFB28"]
            | ["\uFB2A"-"\uFB36"] | ["\uFB38"-"\uFB3C"] | ["\uFB3E"]
            | ["\uFB40"-"\uFB41"] | ["\uFB43"-"\uFB44"] | ["\uFB46"-"\uFBB1"]
            | ["\uFBD3"-"\uFD3D"] | ["\uFD50"-"\uFD8F"] | ["\uFD92"-"\uFDC7"]
            | ["\uFDF0"-"\uFDFB"] | ["\uFE70"-"\uFE72"] | ["\uFE74"]
            | ["\uFE76"-"\uFEFC"] | ["\uFF21"-"\uFF3A"] | ["\uFF41"-"\uFF5A"]
            | ["\uFF66"-"\uFFBE"] | ["\uFFC2"-"\uFFC7"] | ["\uFFCA"-"\uFFCF"]
            | ["\uFFD2"-"\uFFD7"] | ["\uFFDA"-"\uFFDC"] >
} 

/* Unicode categories Non-spacing mark OR Combining spacing mark */
MORE: {
    < UNICODE_COMBINING_MARK: <MN> | <MC> >
}
TOKEN: {
      < MC: 
          ["\u0903"] | ["\u093E"] | ["\u093F"] | ["\u0940"] | ["\u0949"]
        | ["\u094A"] | ["\u094B"] | ["\u094C"] | ["\u0982"] | ["\u0983"]
        | ["\u09BE"] | ["\u09BF"] | ["\u09C0"] | ["\u09C7"] | ["\u09C8"]
        | ["\u09CB"] | ["\u09CC"] | ["\u09D7"] | ["\u0A03"] | ["\u0A3E"]
        | ["\u0A3F"] | ["\u0A40"] | ["\u0A83"] | ["\u0ABE"] | ["\u0ABF"]
        | ["\u0AC0"] | ["\u0AC9"] | ["\u0ACB"] | ["\u0ACC"] | ["\u0B02"]
        | ["\u0B03"] | ["\u0B3E"] | ["\u0B40"] | ["\u0B47"] | ["\u0B48"]
        | ["\u0B4B"] | ["\u0B4C"] | ["\u0B57"] | ["\u0BBE"] | ["\u0BBF"]
        | ["\u0BC1"] | ["\u0BC2"] | ["\u0BC6"] | ["\u0BC7"] | ["\u0BC8"]
        | ["\u0BCA"] | ["\u0BCB"] | ["\u0BCC"] | ["\u0BD7"] | ["\u0C01"]
        | ["\u0C02"] | ["\u0C03"] | ["\u0C41"] | ["\u0C42"] | ["\u0C43"]
        | ["\u0C44"] | ["\u0C82"] | ["\u0C83"] | ["\u0CBE"] | ["\u0CC0"]
        | ["\u0CC1"] | ["\u0CC2"] | ["\u0CC3"] | ["\u0CC4"] | ["\u0CC7"]
        | ["\u0CC8"] | ["\u0CCA"] | ["\u0CCB"] | ["\u0CD5"] | ["\u0CD6"]
        | ["\u0D02"] | ["\u0D03"] | ["\u0D3E"] | ["\u0D3F"] | ["\u0D40"]
        | ["\u0D46"] | ["\u0D47"] | ["\u0D48"] | ["\u0D4A"] | ["\u0D4B"]
        | ["\u0D4C"] | ["\u0D57"] | ["\u0D82"] | ["\u0D83"] | ["\u0DCF"]
        | ["\u0DD0"] | ["\u0DD1"] | ["\u0DD8"] | ["\u0DD9"] | ["\u0DDA"]
        | ["\u0DDB"] | ["\u0DDC"] | ["\u0DDD"] | ["\u0DDE"] | ["\u0DDF"]
        | ["\u0DF2"] | ["\u0DF3"] | ["\u0F3E"] | ["\u0F3F"] | ["\u0F7F"]
        | ["\u102C"] | ["\u1031"] | ["\u1038"] | ["\u1056"] | ["\u1057"]
        | ["\u17B6"] | ["\u17BE"] | ["\u17BF"] | ["\u17C0"] | ["\u17C1"]
        | ["\u17C2"] | ["\u17C3"] | ["\u17C4"] | ["\u17C5"] | ["\u17C7"]
        | ["\u17C8"] | ["\u1923"] | ["\u1924"] | ["\u1925"] | ["\u1926"]
        | ["\u1929"] | ["\u192A"] | ["\u192B"] | ["\u1930"] | ["\u1931"]
        | ["\u1933"] | ["\u1934"] | ["\u1935"] | ["\u1936"] | ["\u1937"]
        | ["\u1938"] | ["\u19B0"] | ["\u19B1"] | ["\u19B2"] | ["\u19B3"]
        | ["\u19B4"] | ["\u19B5"] | ["\u19B6"] | ["\u19B7"] | ["\u19B8"]
        | ["\u19B9"] | ["\u19BA"] | ["\u19BB"] | ["\u19BC"] | ["\u19BD"]
        | ["\u19BE"] | ["\u19BF"] | ["\u19C0"] | ["\u19C8"] | ["\u19C9"]
        | ["\u1A19"] | ["\u1A1A"] | ["\u1A1B"] | ["\uA802"] | ["\uA823"]
        | ["\uA824"] | ["\uA827"] | ["\u1D16"] | ["\u1D16"] | ["\u1D16"]
        | ["\u1D16"] | ["\u1D16"] | ["\u1D17"] | ["\u1D17"] | ["\u1D17"] >
    | < MN: 
          ["\u0300"-"\u034E"] | ["\u0360"-"\u0362"] | ["\u0483"-"\u0486"] 
        | ["\u0591"-"\u05A1"] | ["\u05A3"-"\u05B9"] | ["\u05BB"-"\u05BD"] 
        | ["\u05BF"]          | ["\u05C1"-"\u05C2"] | ["\u05C4"]
        | ["\u064B"-"\u0655"] | ["\u0670"]          | ["\u06D6"-"\u06DC"]
        | ["\u06DF"-"\u06E4"] | ["\u06E7"-"\u06E8"] | ["\u06EA"-"\u06ED"] 
        | ["\u0711"]          | ["\u0730"-"\u074A"] | ["\u07A6"-"\u07B0"] 
        | ["\u0901"-"\u0903"] | ["\u093C"]          | ["\u093E"-"\u094D"] 
        | ["\u0951"-"\u0954"] | ["\u0962"-"\u0963"] | ["\u0981"-"\u0983"]
        | ["\u09BC"-"\u09C4"] | ["\u09C7"-"\u09C8"] | ["\u09CB"-"\u09CD"] 
        | ["\u09D7"]          | ["\u09E2"-"\u09E3"] | ["\u0A02"]
        | ["\u0A3C"]          | ["\u0A3E"-"\u0A42"] | ["\u0A47"-"\u0A48"] 
        | ["\u0A4B"-"\u0A4D"] | ["\u0A70"-"\u0A71"] | ["\u0A81"-"\u0A83"] 
        | ["\u0ABC"]          | ["\u0ABE"-"\u0AC5"] | ["\u0AC7"-"\u0AC9"] 
        | ["\u0ACB"-"\u0ACD"] | ["\u0B01"-"\u0B03"] | ["\u0B3C"]
        | ["\u0B3E"-"\u0B43"] | ["\u0B47"-"\u0B48"] | ["\u0B4B"-"\u0B4D"] 
        | ["\u0B56"-"\u0B57"] | ["\u0B82"-"\u0B83"] | ["\u0BBE"-"\u0BC2"]
        | ["\u0BC6"-"\u0BC8"] | ["\u0BCA"-"\u0BCD"] | ["\u0BD7"]
        | ["\u0C01"-"\u0C03"] | ["\u0C3E"-"\u0C44"] | ["\u0C46"-"\u0C48"] 
        | ["\u0C4A"-"\u0C4D"] | ["\u0C55"-"\u0C56"] | ["\u0C82"-"\u0C83"] 
        | ["\u0CBE"-"\u0CC4"] | ["\u0CC6"-"\u0CC8"] | ["\u0CCA"-"\u0CCD"]
        | ["\u0CD5"-"\u0CD6"] | ["\u0D02"-"\u0D03"] | ["\u0D3E"-"\u0D43"] 
        | ["\u0D46"-"\u0D48"] | ["\u0D4A"-"\u0D4D"] | ["\u0D57"]
        | ["\u0D82"-"\u0D83"] | ["\u0DCA"]          | ["\u0DCF"-"\u0DD4"] 
        | ["\u0DD6"]          | ["\u0DD8"-"\u0DDF"] | ["\u0DF2"-"\u0DF3"]
        | ["\u0E31"]          | ["\u0E34"-"\u0E3A"] | ["\u0E47"-"\u0E4E"] 
        | ["\u0EB1"]          | ["\u0EB4"-"\u0EB9"] | ["\u0EBB"-"\u0EBC"] 
        | ["\u0EC8"-"\u0ECD"] | ["\u0F18"-"\u0F19"] | ["\u0F35"]
        | ["\u0F37"]          | ["\u0F39"]          | ["\u0F3E"-"\u0F3F"]
        | ["\u0F71"-"\u0F84"] | ["\u0F86"-"\u0F87"] | ["\u0F90"-"\u0F97"] 
        | ["\u0F99"-"\u0FBC"] | ["\u0FC6"]          | ["\u102C"-"\u1032"] 
        | ["\u1036"-"\u1039"] | ["\u1056"-"\u1059"] | ["\u17B4"-"\u17D3"] 
        | ["\u18A9"]          | ["\u20D0"-"\u20DC"] | ["\u20E1"]
        | ["\u302A"-"\u302F"] | ["\u3099"-"\u309A"] | ["\uFB1E"]
        | ["\uFE20"-"\uFE23"] >
}

TOKEN: {
    < UNICODE_DIGIT: 
          ["\u0030"-"\u0039"] | ["\u0660"-"\u0669"] | ["\u06F0"-"\u06F9"] 
        | ["\u0966"-"\u096F"] | ["\u09E6"-"\u09EF"] | ["\u0A66"-"\u0A6F"] 
        | ["\u0AE6"-"\u0AEF"] | ["\u0B66"-"\u0B6F"] | ["\u0BE7"-"\u0BEF"] 
        | ["\u0C66"-"\u0C6F"] | ["\u0CE6"-"\u0CEF"] | ["\u0D66"-"\u0D6F"]
        | ["\u0E50"-"\u0E59"] | ["\u0ED0"-"\u0ED9"] | ["\u0F20"-"\u0F29"] 
        | ["\u1040"-"\u1049"] | ["\u1369"-"\u1371"] | ["\u17E0"-"\u17E9"] 
        | ["\u1810"-"\u1819"] | ["\uFF10"-"\uFF19"] >
}

TOKEN: {
    < UNICODE_CONNECTOR_PUNCTUATION:  
          ["\u005F"]          | ["\u203F"-"\u2040"] | ["\u30FB"] 
        | ["\uFE33"-"\uFE34"] | ["\uFE4D"-"\uFE4F"] | ["\uFF3F"]
        | ["\uFF65"] >
}

TOKEN : {
    < UNICODE_ESCAPE_SEQUENCE : "u" < HEX_DIGIT > < HEX_DIGIT > < HEX_DIGIT > < HEX_DIGIT >>
}

/**
 * Parse a JSON document or array.
 */
protected Object parse() : {
    Object result = null;
}
{
    ( result = document(null) | result = array(null) )
    {
        return result;
    }
}

/**
 * Parse a JSON document.
 */
private Document document(DocumentBuilder builder) : {
    DocumentBuilder b = builder;
    if( b == null ) {
        b = BuilderFactory.start();
    }
}
{
    ( <TOKEN_OPEN_BRACE> ( members(b) )? <TOKEN_CLOSE_BRACE> )
    {
        return b.build();
    }
}

/**
 * Parse a JSON array.
 */
private List<Element> array(ArrayBuilder builder) : {
    ArrayBuilder b = builder;
    if( b == null ) {
        b = BuilderFactory.startArray();
    }
}
{
    ( <TOKEN_OPEN_BRACKET> ( elements(b) )? <TOKEN_CLOSE_BRACKET> )
    {
        return Arrays.asList(b.build());
    }
}

/**
 * Parse the members of a JSON document.
 */
private void members(DocumentBuilder builder) : {
}
{
    pair(builder) [ <TOKEN_COMMA> members(builder) ]
}

/**
 * Parse the a single member of JSON document.
 */
private void pair(DocumentBuilder builder) : {
    Token nameToken = null;
    String name = null;
}
{
    (
          nameToken = <IDENTIFIER_NAME> { name = nameToken.image; }
        | nameToken = <STRING_LITERAL> { name = trimQuotes( nameToken.image ); } 
        | nameToken = <HEX_DIGIT> { name = nameToken.image; } 
    ) <TOKEN_COLON> documentValue(name, builder)
}

/**
 * Parse the members of a JSON array.
 */
private void elements(ArrayBuilder builder) : {
}
{
    arrayValue(builder) [ <TOKEN_COMMA> elements(builder) ]
}


/**
 * Parse a JSON value in an array.
 */
private void arrayValue(ArrayBuilder builder) : {
    Token t1 = null;
    Token t2 = null;
    Token t3 = null;
    Token t4 = null;
}
{
    (
        LOOKAHEAD(2) 
        "{" 
        ( 
           <TOKEN_BINARY> <TOKEN_COLON> t2 = <STRING_LITERAL> <TOKEN_COMMA> <TOKEN_TYPE> <TOKEN_COLON> ( t1 = <INTEGER> | t3 = <STRING_LITERAL> )
           {
              if( t1 != null ) {
                  builder.addBinary( (byte) Integer.parseInt(t1.image), toBinaryFromBase64(t2) );
              } else { 
                  builder.addBinary( (byte) toIntFromHex(t3), toBinaryFromBase64(t2) );
              }
           }
         | <TOKEN_TYPE> <TOKEN_COLON> ( t1 = <INTEGER> | t3 = <STRING_LITERAL> ) <TOKEN_COMMA> <TOKEN_BINARY> <TOKEN_COLON> t2 = <STRING_LITERAL>
           {
              if( t1 != null ) {
                  builder.addBinary( (byte) Integer.parseInt(t1.image), toBinaryFromBase64(t2) );
              } else { 
                  builder.addBinary( (byte) toIntFromHex(t3), toBinaryFromBase64(t2) );
              }
           }
         | <TOKEN_DATE> <TOKEN_COLON> ( t1 = <INTEGER> | t2 = <STRING_LITERAL> )
           {
              if ( t1 != null ) {
                  builder.add( toDateFromEpoch(t1) );
              } else { 
                  builder.add( toDate(t2) );
              }
           }
         | <TOKEN_TS>  <TOKEN_COLON> "{" 
                 (t1 = <IDENTIFIER_NAME> | t1 = <STRING_LITERAL> ) <TOKEN_COLON> t2 = <INTEGER> <TOKEN_COMMA> 
                 (t3 = <IDENTIFIER_NAME> | t3 = <STRING_LITERAL> ) <TOKEN_COLON> t4 = <INTEGER> "}"
           {
              builder.addMongoTimestamp( toMongoTimestamp(t1, t2, t3, t4) );
           }
         | <TOKEN_REGEX> <TOKEN_COLON> t1 = <STRING_LITERAL> ( <TOKEN_COMMA> <TOKEN_OPTIONS> <TOKEN_COLON> t2 = <STRING_LITERAL> )?
           {
              if ( t2 != null ) {
                  builder.addRegularExpression( trimQuotes(t1.image), trimQuotes(t2.image) );
              } else {
                  builder.addRegularExpression( trimQuotes(t1.image), "" );
              }
           }
         | <TOKEN_OPTIONS> <TOKEN_COLON> t2 = <STRING_LITERAL> <TOKEN_COMMA> <TOKEN_REGEX> <TOKEN_COLON> t1 = <STRING_LITERAL>
          {
              builder.addRegularExpression( trimQuotes(t1.image), trimQuotes(t2.image) );
          }
         | <TOKEN_OID> <TOKEN_COLON> t1 = <STRING_LITERAL>
          {
              builder.addObjectId( toObjectId(t1) );
          }
         | <TOKEN_MAX> <TOKEN_COLON> <INTEGER>
          {
             builder.addMaxKey();
          }
         | <TOKEN_MIN> <TOKEN_COLON> <INTEGER>
          {
             builder.addMinKey();
          }
        ) 
        "}"
        | document(builder.push())
        | array(builder.pushArray()) 
        | t1 = <HEX_DIGIT> { builder.addSymbol(t1.image); }
        | t1 = <IDENTIFIER_NAME> { builder.addSymbol(t1.image); }
        | t1 = <STRING_LITERAL> { builder.addString(trimQuotes(t1.image)); }
        | t1 = <DOUBLE> { builder.addDouble(Double.parseDouble(t1.image)); }
        | t1 = <INTEGER> 
          {
             // Experimentally determine the size of the integer.
             long value = Long.parseLong(t1.image);
             if( (Integer.MIN_VALUE <= value) && (value <= Integer.MAX_VALUE) ) {
                builder.addInteger((int) value);              
             } else {
                builder.addLong(value); 
             }
          }
        | <TOKEN_TRUE> { builder.addBoolean(true); }
        | <TOKEN_FALSE> { builder.addBoolean(false); }
        | <TOKEN_NULL> { builder.addNull(); }
        | <TOKEN_BINDATA> "(" t1 = <INTEGER> <TOKEN_COMMA> t2 = <STRING_LITERAL> ")" 
          {
             builder.addBinary( (byte) Integer.parseInt(t1.image), toBinaryFromBase64(t2) );
          }
        | <TOKEN_HEXDATA> "(" t1 = <INTEGER> <TOKEN_COMMA> t2 = <STRING_LITERAL> ")" 
          {
             builder.addBinary( (byte) Integer.parseInt(t1.image), toBinaryFromHex(t2) );
          }
        | <TOKEN_ISODATE> "(" t1 = <STRING_LITERAL> ")"
          { 
             builder.add( toDate(t1) );
          }
        | <TOKEN_NUMBERLONG> "(" t1 = <STRING_LITERAL> ")"
          { 
             builder.addLong(Long.parseLong(trimQuotes(t1.image))); 
          }
        | <TOKEN_OBJECTID> "(" t1 = <STRING_LITERAL> ")"
          {
             builder.addObjectId( toObjectId(t1) );
          } 
        | <TOKEN_TIMESTAMP> "(" t1 = <INTEGER> <TOKEN_COMMA> t2 = <INTEGER> ")" 
          { 
             builder.addMongoTimestamp( toMongoTimestamp(t1, t2) );
          }
        | <TOKEN_MAXKEY> ( "(" ")" )?
          {
             builder.addMaxKey();
          }
        | <TOKEN_MINKEY> ( "(" ")" )?
          { 
             builder.addMinKey();
          }
        | <TOKEN_DB_POINTER> "(" t1 = <STRING_LITERAL> <TOKEN_COMMA> t2 = <STRING_LITERAL> <TOKEN_COMMA> <TOKEN_OBJECTID> "(" t3 = <STRING_LITERAL> ")" ")" 
          { 
             builder.addDBPointer(trimQuotes(t1.image), trimQuotes(t2.image), toObjectId(t3));
          }
    )
}

/**
 * Parse a JSON value in a document.
 */
private void documentValue(String name, DocumentBuilder builder) : {
    Token t1 = null;
    Token t2 = null;
    Token t3 = null;
    Token t4 = null;
}
{
    (
        LOOKAHEAD(2) 
        "{" 
        ( 
            <TOKEN_BINARY> <TOKEN_COLON> t2 = <STRING_LITERAL> <TOKEN_COMMA> <TOKEN_TYPE> <TOKEN_COLON> ( t1 = <INTEGER> | t3 = <STRING_LITERAL> )
           {
              if( t1 != null ) {
                  builder.addBinary( name, (byte) Integer.parseInt(t1.image), toBinaryFromBase64(t2) );
              } else { 
                  builder.addBinary( name, (byte) toIntFromHex(t3), toBinaryFromBase64(t2) );
              }
           }
         | <TOKEN_TYPE> <TOKEN_COLON> ( t1 = <INTEGER> | t3 = <STRING_LITERAL> ) <TOKEN_COMMA> <TOKEN_BINARY> <TOKEN_COLON> t2 = <STRING_LITERAL>
           {
              if( t1 != null ) {
                  builder.addBinary( name, (byte) Integer.parseInt(t1.image), toBinaryFromBase64(t2) );
              } else { 
                  builder.addBinary( name, (byte) toIntFromHex(t3), toBinaryFromBase64(t2) );
              }
           }
         | <TOKEN_DATE> <TOKEN_COLON> ( t1 = <INTEGER> | t2 = <STRING_LITERAL> )
           {
              if ( t1 != null ) {
                  builder.add( name, toDateFromEpoch(t1) );
              } else { 
                  builder.add( name, toDate(t2) );
              }
           }
         | <TOKEN_TS>  <TOKEN_COLON> "{" 
                 (t1 = <IDENTIFIER_NAME> | t1 = <STRING_LITERAL> ) <TOKEN_COLON> t2 = <INTEGER> <TOKEN_COMMA> 
                 (t3 = <IDENTIFIER_NAME> | t3 = <STRING_LITERAL> ) <TOKEN_COLON> t4 = <INTEGER> "}"
           {
              builder.addMongoTimestamp( name, toMongoTimestamp(t1, t2, t3, t4) );
           }
         | <TOKEN_REGEX> <TOKEN_COLON> t1 = <STRING_LITERAL> ( <TOKEN_COMMA> <TOKEN_OPTIONS> <TOKEN_COLON> t2 = <STRING_LITERAL> )?
           {
              if ( t2 != null ) {
                  builder.addRegularExpression( name, trimQuotes(t1.image), trimQuotes(t2.image) );
              } else {
                  builder.addRegularExpression( name, trimQuotes(t1.image), "" );
              }
           }
         | <TOKEN_OPTIONS> <TOKEN_COLON> t2 = <STRING_LITERAL> <TOKEN_COMMA> <TOKEN_REGEX> <TOKEN_COLON> t1 = <STRING_LITERAL>
          {
              builder.addRegularExpression( name, trimQuotes(t1.image), trimQuotes(t2.image) );
          }
         | <TOKEN_OID> <TOKEN_COLON> t1 = <STRING_LITERAL>
          {
              builder.addObjectId( name, toObjectId(t1) );
          }
         | <TOKEN_MAX> <TOKEN_COLON> <INTEGER>
          {
             builder.addMaxKey(name);
          }
         | <TOKEN_MIN> <TOKEN_COLON> <INTEGER>
          {
             builder.addMinKey(name);
          }
        ) 
        "}"
        | document(builder.push(name)) 
        | array(builder.pushArray(name)) 
        | t1 = <HEX_DIGIT> { builder.addSymbol(name, t1.image); }
        | t1 = <IDENTIFIER_NAME> { builder.addSymbol(name, t1.image); }
        | t1 = <STRING_LITERAL> { builder.addString(name, trimQuotes(t1.image)); }
        | t1 = <DOUBLE> { builder.addDouble(name, Double.parseDouble(t1.image)); }
        | t1 = <INTEGER> 
          {
             // Experimentally determine the size of the integer.
             long value = Long.parseLong(t1.image);
             if( (Integer.MIN_VALUE <= value) && (value <= Integer.MAX_VALUE) ) {
                builder.addInteger(name, (int) value);              
             } else {
                builder.addLong(name, value); 
             }
          }
        | <TOKEN_TRUE> { builder.addBoolean(name, true); }
        | <TOKEN_FALSE> { builder.addBoolean(name, false); }
        | <TOKEN_NULL> { builder.addNull(name); }
        | <TOKEN_BINDATA> "(" t1 = <INTEGER> <TOKEN_COMMA> t2 = <STRING_LITERAL> ")" 
          {
             builder.addBinary( name, (byte) Integer.parseInt(t1.image), toBinaryFromBase64(t2) );
          }
        | <TOKEN_HEXDATA> "(" t1 = <INTEGER> <TOKEN_COMMA> t2 = <STRING_LITERAL> ")" 
          {
             builder.addBinary( name, (byte) Integer.parseInt(t1.image), toBinaryFromHex(t2) );
          }
        | <TOKEN_ISODATE> "(" t1 = <STRING_LITERAL> ")"
          { 
             builder.add( name, toDate(t1) );
          }
        | <TOKEN_NUMBERLONG> "(" t1 = <STRING_LITERAL> ")"
          { 
             builder.addLong(name, Long.parseLong(trimQuotes(t1.image))); 
          }
        | <TOKEN_OBJECTID> "(" t1 = <STRING_LITERAL> ")"
          {
             builder.addObjectId( name, toObjectId(t1) );
          } 
        | <TOKEN_TIMESTAMP> "(" t1 = <INTEGER> <TOKEN_COMMA> t2 = <INTEGER> ")" 
          { 
             builder.addMongoTimestamp( name, toMongoTimestamp(t1, t2) );
          }
        | <TOKEN_MAXKEY> ( "(" ")" )? 
          {
             builder.addMaxKey(name);
          }
        | <TOKEN_MINKEY> ( "(" ")" )? 
          { 
             builder.addMinKey(name);
          }
        | <TOKEN_DB_POINTER> "(" t1 = <STRING_LITERAL> <TOKEN_COMMA> t2 = <STRING_LITERAL> <TOKEN_COMMA> <TOKEN_OBJECTID> "(" t3 = <STRING_LITERAL> ")" ")" 
          { 
             builder.addDBPointer(name, trimQuotes(t1.image), trimQuotes(t2.image), toObjectId(t3));
          }
    )
}

